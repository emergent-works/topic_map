<?php


require_once "src/TopicRelations.php";
//require_once "topic_map.views_execution.inc";    // Doesn't work https://drupal.stackexchange.com/questions/245447
use Drupal\topic_map\TopicRelations;

// Implement hook_form_alter.
// We assume that if these fields are present, it's a topic map vocabulary and we want to ensure terms don't get related to themselves.
function topic_map_form_alter(&$form,  &$form_state, $form_id) {
  if (array_key_exists('field_children', $form) && array_key_exists('field_parents', $form) && array_key_exists('field_neighbours', $form) ) {
    $form['#validate'][] = 'TopicRelations_validate';
  }
}

// Implements hook_taxonomy_term_insert.
function topic_map_taxonomy_term_insert($term) {
  $tr = new TopicRelations();
  $tr->onInsert($term);
}

// Implements hook_taxonomy_term_update.
function topic_map_taxonomy_term_update($term) {
  $tr = new TopicRelations();
  $tr->onUpdate($term);
}

// Attaches css to the relevant pages so that the built-in taxonomy
// hierarchy functionality is not visible
function topic_map_page_attachments(array &$attachments) {
  $attachments['#attached']['library'][] = 'topic_map/relations';
}

// Causes our help text to generated before the standard taxonomy help.
// This allows us to use the sibling selector in the css to remove the
// standard help text.
function topic_map_module_implements_alter(&$implementations, $hook) {
 if ($hook == 'help') {
    $implementations = array('topic_map' => $implementations['topic_map']) + $implementations;
  }
}

// Places this help text on all vocabulary overview pages. Whether this or the default text is shown is governed by condtionally-loaded CSS
function topic_map_help($route_name, \Drupal\Core\Routing\RouteMatchInterface $route_match) {
  if  ($route_name == "entity.taxonomy_vocabulary.overview_form") {
    return "<p id='replacement_taxonomy_help'>This vocabulary uses the Topic Map module and therefore the default hierarchical relationships between terms are disabled. You can use the fields to create relationships between terms. The topic map for this vocabulary is available as a block.</p>";
  }
}

// Stops the user from relating a term to itself
function TopicRelations_validate($form, $form_state) {
  $term_id = $form_state->getFormObject()->getEntity()->id();
  $children = $form_state->getValue('field_children');
  for($i = 0; $i < sizeof($children); $i++) {
    if(is_array($children[$i]) && $children[$i]['target_id'] == $term_id) {
      $form_state->setErrorByName("field_children][$i", t('A term cannot be its own child'));
    }
  }
  $parents = $form_state->getValue('field_parents');
  for($i = 0; $i < sizeof($parents); $i++) {
    if(is_array($parents[$i]) && $parents[$i]['target_id'] == $term_id) {
      $form_state->setErrorByName("field_parents][$i", t('A term cannot be its own parent'));
    }
  }
  $neighbours = $form_state->getValue('field_neighbours');
  for($i = 0; $i < sizeof($neighbours); $i++) {
    if(is_array($neighbours[$i]) && $neighbours[$i]['target_id'] == $term_id) {
      $form_state->setErrorByName("field_neighbours][$i", t('A term cannot be its own neighbour'));
    }
  }
}

